What happens when you initialize a repository? Why do you need to do it?
	(git init) It creates a new git repository. 
	(ls -a)  A git directory will be created in the directory of the files. 


How is the staging area different from the working directory and the repository?
What value do you think it offers?
	Staging area provides a space to compile what the commit you want to submit at a time.
	Working directory is the place stores the actual repository.


How can you use the staging area to make sure you have one commit per logical
change?
	Store only files with certain logical change to be committed in a repository to the staging area. 
	(git commit) those files with the logical change at a time. 
	(git add) the other logical change to the staging area and commit it again. 
	(git reset) to remove the file from staging area. 


What are some situations when branches would be helpful in keeping your history
organized? How would branches help?
	When try to develop new features while having the current latest version available to be used/reviewed. 
	Once the new features could work properly, this branch can be merged with the master branch that has gone on for a few commits.
	Usually: master branch to be open to the public, other branches to experiment or adding new features that are not yet quality-checked.

	Another usage of branch is to develop different version or special version. (e.g., easy mode, area-customed) 


How do the diagrams help you visualize the branch structure?
	A diagram illustrates the parent of every commits in different branches, showing from which commit did you start a new branch. 
	It helps keep tracks of which branches contain which commits. 


What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?
	To merge a branch into the master branch: (git checkout master) to make sure you are at the master branch.
	(git merge master anotherBranch) checks the edition of the two branches against the original commit (where a new branch is created), and create a new commit. In the diagram, we can track every commit in the two branches from the new commit of the merged two branches. 
	(git merge --abort) to abort the merge and go back to the status before merge happens.
	If a branch is merged to the master branch, we can remove the label of the branch by (git branch -d nameOfTheBranch). Note that this wouldn't delete the commits in that branch. 


What are the pros and cons of Git's automatic merging vs. always doing merges
manually?
	Git's automatic merging would warn you conflict if there's diff of one line in the commits you want to merge. To resolve the conflict, you can check the file in which the conflict part is now marked by git: 
	
	<<<<<<<HEAD
	(The code in the checkout branch)
	|||||||| merged common ancestors
	(The code of 2 branches' common ancestor)
	=======
	(the code of the master branch)
	>>>>>>> master  

	Check the code change and determine to use a certain version of the code. Modify the code and save the file. 
	Check (git status): 
	On branch easy-mode
	You have unmerged paths.
  	(fix conflicts and run "git commit")
  	(use "git merge --abort" to abort the merge)

	Unmerged paths:
  	(use "git add <file>..." to mark resolution)
        both modified:   game.js
 	
 	(git add) (git commit) to submit the merged commit